using Moq;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using SeadQueryCore;
using SeadQueryCore.Model;
using SQT;
using SQT.ClassData;
using SQT.Infrastructure;
using SQT.SQL.Matcher;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using Xunit;

namespace IntegrationTests
{
    public class ResultTestStartupWithContainer : TestStartup<TestDependencyService>
    {
    }

    public class ResultTestHostWithContainer : TestHostBuilderFixture<ResultTestStartupWithContainer>
    {

    }

    [Collection("JsonSeededFacetContext")]
    public class ResultControllerTests : ControllerTest<ResultTestHostWithContainer>, IClassFixture<ResultTestHostWithContainer>
    {
        public JsonSeededFacetContextFixture FacetContextFixture { get; }
        public DisposableFacetContextContainer MockService { get; }

        public ResultControllerTests(ResultTestHostWithContainer hostBuilderFixture, JsonSeededFacetContextFixture facetContextFixture) : base(hostBuilderFixture)
        {
            FacetContextFixture = facetContextFixture;
            MockService = new DisposableFacetContextContainer(facetContextFixture);
        }

        [Fact]
        public async Task API_GET_Server_IsAwake()
        {
            using (var response = await Fixture.Client.GetAsync("api/values")) {
                response.EnsureSuccessStatusCode();
                Assert.NotEmpty(await response.Content.ReadAsStringAsync());
            }
        }

        public class LoadPayload {
            #pragma warning disable IDE1006 // Naming Styles
            public FacetsConfig2 facetsConfig { get; set; }
            public ResultConfig resultConfig { get; set; }
            #pragma warning restore IDE1006 // Naming Styles
        }

        protected StringContent FakeLoadResultPayload(string uri, string resultFacetCode, string specificationKey, string viewType)
        {
            var facetsConfig = MockService.FakeFacetsConfig(uri);
            var resultConfig = MockService.FakeResultConfig(resultFacetCode, specificationKey, viewType);
            var bothConfigs = new LoadPayload { facetsConfig = facetsConfig, resultConfig = resultConfig };
            var json = JsonConvert.SerializeObject(bothConfigs);
            var payload = new StringContent(json, Encoding.UTF8, "application/json");
            return payload;
        }

        /// <summary>
        /// Integeration test of SQL generated by a call to "api/facets/load"
        /// </summary>
        /// <param name="uri">Facet configuration</param>
        /// <param name="expectedJoinCount">Basically the number of tables involved in the join i.e. unique routes returned from Graoh.Find</param>
        /// <returns></returns>
        [Theory]
        [InlineData("genus:dataset_master@10/sites@1985,2044,2046,2017,2045/genus@764,551")]
        [InlineData("relative_age_name:relative_age_name", "tbl_analysis_entities")]
        [InlineData("dataset_master:dataset_master@1", "tbl_analysis_entities", "tbl_dataset_masters", "tbl_datasets")]
        [InlineData("country:country@10", "tbl_analysis_entities", "tbl_locations")]
        [InlineData("country:country", "tbl_analysis_entities", "tbl_locations", "tbl_sites")]
        [InlineData("sites:country@10/sites", "tbl_analysis_entities", "tbl_sites", "tbl_sample_groups", "tbl_physical_samples")]
        [InlineData("sites:sites", "tbl_analysis_entities", "tbl_sites", "tbl_sample_groups", "tbl_physical_samples")]
        [InlineData("pollen://sites:sites", "tbl_analysis_entities", "tbl_sites", "tbl_sample_groups", "tbl_physical_samples")]
        [InlineData("ceramic://sites:sites", "tbl_analysis_entities", "tbl_sites", "tbl_sample_groups", "tbl_physical_samples")]
        [InlineData("palaeoentomology://data_types:data_types", "tbl_analysis_entities", "tbl_datasets")]
        //[InlineData("palaeoentomology://data_types:data_types@3", "tbl_data_types", "tbl_analysis_entities", "tbl_datasets")]
        public async Task Load_VariousFacetConfigs_HasExpectedSqlQuery(string uri, params string[] expectedJoins)
        {
            // Arrange
            var facetsConfig = MockService.FakeFacetsConfig(uri);
            var resultConfig = MockService.FakeResultConfig("result_facet", "site_level", "tabular");
            var bothConfigs = new LoadPayload { facetsConfig = facetsConfig, resultConfig = resultConfig };
            var json = JsonConvert.SerializeObject(bothConfigs);
            var payload = new StringContent(json, Encoding.UTF8, "application/json");

            // Act
            using var response = await Fixture.Client.PostAsync("api/result/load", payload);

            // Assert
            response.EnsureSuccessStatusCode();

            var responseContent = await response.Content.ReadAsStringAsync();

            var result = JsonConvert.DeserializeObject<ResultContentSet>(responseContent);

            Assert.NotNull(result);
            Assert.NotNull(result.Data);
            Assert.NotNull(result.Data.DataCollection);
            Assert.NotNull(result.Meta);
            Assert.NotNull(result.Meta.Columns);
            Assert.NotEmpty(result.Query);

            var sqlQuery = result.Query.Squeeze();

            var matcher = new TabularResultSqlCompilerMatcher();
            var match = matcher.Match(sqlQuery);

            Assert.True(match.Success);
            Assert.True(match.InnerSelect.Success);
            Assert.NotEmpty(match.InnerSelect.Tables);

            Assert.True(expectedJoins.All(x => match.InnerSelect.Tables.Contains(x)));
        }

        /// <summary>
        /// Tests all domain facets
        /// </summary>
        /// <param name="uri"></param>
        /// <param name="expectedJoins"></param>
        /// <returns></returns>
        [Theory]
        [ClassData(typeof(CompleteSetOfSingleTabularResultUriCollection))]
        public async Task LoadTabular_DomainFacetsWithSingleChildFacet_HasExpectedSqlQuery(string uri, string resultFacetCode, string specificationKey, string viewType)
        {
            // Arrange
            var payload = FakeLoadResultPayload(uri, resultFacetCode, specificationKey, viewType);

            // Act
            /* using */ var response = await Fixture.Client.PostAsync("api/result/load", payload);

            // Assert
            response.EnsureSuccessStatusCode();

            var responseContent = await response.Content.ReadAsStringAsync();

            var result = JsonConvert.DeserializeObject<ResultContentSet>(responseContent);

            Assert.NotNull(result);
            Assert.NotNull(result.Data);
            Assert.NotNull(result.Data.DataCollection);
            Assert.NotNull(result.Meta);
            Assert.NotNull(result.Meta.Columns);
            Assert.NotEmpty(result.Query);

            var sqlQuery = result.Query.Squeeze();

            var matcher = new TabularResultSqlCompilerMatcher();
            var match = matcher.Match(sqlQuery);

            Assert.True(match.Success);
            Assert.True(match.InnerSelect.Success);
            Assert.NotEmpty(match.InnerSelect.Tables);

        }

        /// <summary>
        /// Tests all domain facets
        /// </summary>
        /// <param name="uri"></param>
        /// <param name="expectedJoins"></param>
        /// <returns></returns>
        [Theory]
        [InlineData("sites:data_types@5/rdb_codes@13,21/sites", "map_result", "site_level", "map")]
        [ClassData(typeof(CompleteSetOfSingleMapResultUriCollection))]
        public async Task LoadMap_StateUnderTest_ExpectedBehavior(string uri, string resultFacetCode, string specificationKey, string viewType)
        {
            // Arrange
            var payload = FakeLoadResultPayload(uri, resultFacetCode, specificationKey, viewType);

            // Act
            /* using */ var response = await Fixture.Client.PostAsync("api/result/load", payload);

            // Assert
            response.EnsureSuccessStatusCode();

            var responseContent = await response.Content.ReadAsStringAsync();

            var result = JsonConvert.DeserializeObject<ResultContentSet>(responseContent);

            Assert.NotNull(result);
            Assert.NotNull(result.Data);
            Assert.NotNull(result.Data.DataCollection);
            Assert.NotNull(result.Meta);
            Assert.NotNull(result.Meta.Columns);
            Assert.True(result.Meta.Columns.Any());
            Assert.NotEmpty(result.Query);

            var sqlQuery = result.Query.Squeeze();

            var matcher = new MapResultSqlCompilerMatcher();
            var match = matcher.Match(sqlQuery);

            Assert.True(match.Success);

        }
    }
}
